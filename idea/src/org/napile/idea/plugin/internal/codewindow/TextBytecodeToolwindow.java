/*
 * Copyright 2010-2013 napile.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * @author max
 */
package org.napile.idea.plugin.internal.codewindow;

import java.awt.BorderLayout;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Collections;

import javax.swing.JPanel;

import org.napile.asm.LangVersion;
import org.napile.asm.io.AsmWriterOption;
import org.napile.asm.io.xml.out.AsmTextTextWriter;
import org.napile.asm.tree.members.ClassNode;
import org.napile.compiler.analyzer.AnalyzeExhaust;
import org.napile.compiler.codegen.CompilationErrorHandler;
import org.napile.compiler.codegen.GenerationState;
import org.napile.compiler.codegen.Progress;
import org.napile.compiler.lang.psi.NapileFile;
import org.napile.idea.plugin.project.WholeProjectAnalyzerFacade;
import com.intellij.ide.highlighter.XmlFileType;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.application.Result;
import com.intellij.openapi.command.WriteCommandAction;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.editor.EditorFactory;
import com.intellij.openapi.editor.ex.EditorEx;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Comparing;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.util.Alarm;

public class TextBytecodeToolwindow extends JPanel implements Disposable
{
	private static final int UPDATE_DELAY = 500;
	private static final String DEFAULT_TEXT =
			"<!--\n" +
			"Generated bytecode for Napile source file.\n" +
			"No Napile source file is opened.\n" +
			"-->";

	private final Editor myEditor;
	private final Alarm myUpdateAlarm;
	private Location myCurrentLocation;
	private final Project myProject;


	public TextBytecodeToolwindow(Project project)
	{
		super(new BorderLayout());
		myProject = project;
		myEditor = EditorFactory.getInstance().createEditor(EditorFactory.getInstance().createDocument(""), project, XmlFileType.INSTANCE, true);
		add(myEditor.getComponent());
		myUpdateAlarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD, this);
		myUpdateAlarm.addRequest(new Runnable()
		{
			@Override
			public void run()
			{
				myUpdateAlarm.addRequest(this, UPDATE_DELAY);
				Location location = Location.fromEditor(FileEditorManager.getInstance(myProject).getSelectedTextEditor());
				if(!Comparing.equal(location, myCurrentLocation))
				{
					updateBytecode(location, myCurrentLocation);
					myCurrentLocation = location;
				}
			}
		}, UPDATE_DELAY);
	}

	private void updateBytecode(Location location, Location oldLocation)
	{
		Editor editor = location.editor;

		if(editor == null)
		{
			setText(DEFAULT_TEXT);
		}
		else
		{
			VirtualFile vFile = ((EditorEx) editor).getVirtualFile();
			if(vFile == null)
			{
				setText(DEFAULT_TEXT);
				return;
			}

			PsiFile psiFile = PsiManager.getInstance(myProject).findFile(vFile);
			if(!(psiFile instanceof NapileFile))
			{
				setText(DEFAULT_TEXT);
				return;
			}

			if(oldLocation == null ||
					!Comparing.equal(oldLocation.editor, location.editor) ||
					oldLocation.modificationStamp != location.modificationStamp)
			{
				setText(generateToText((NapileFile) psiFile));
			}
		}
	}

	private void setText(final String text)
	{
		new WriteCommandAction(myProject)
		{
			@Override
			protected void run(Result result) throws Throwable
			{
				myEditor.getDocument().setText(text);
			}
		}.execute();
	}

	protected String generateToText(NapileFile file)
	{
		GenerationState state;
		try
		{
			AnalyzeExhaust binding = WholeProjectAnalyzerFacade.analyzeProjectWithCacheOnAFile(file);
			//            AnalyzingUtils.throwExceptionOnErrors(binding);
			if(binding.isError())
			{
				return printStackTraceToString(binding.getError());
			}
			state = new GenerationState(myProject, Progress.DEAF, binding, Collections.singletonList(file));
			state.compileAndGenerate(CompilationErrorHandler.THROW_EXCEPTION);
		}
		catch(Exception e)
		{
			return printStackTraceToString(e);
		}

		StringBuilder answer = new StringBuilder();

		AsmTextTextWriter writer = new AsmTextTextWriter();
		writer.enableOption(AsmWriterOption.INSTRUCTION_INDEX_IN_COMMENT);
		for(ClassNode classNode : state.getClassNodes().values())
			answer.append(writer.write(LangVersion.CURRENT, classNode));

		return answer.toString();
	}

	private static String printStackTraceToString(Throwable e)
	{
		StringWriter out = new StringWriter(1024);
		e.printStackTrace(new PrintWriter(out));
		return out.toString().replace("\r", "");
	}

	@Override
	public void dispose()
	{
		EditorFactory.getInstance().releaseEditor(myEditor);
	}

	public static class Location
	{
		final Editor editor;
		final long modificationStamp;
		final int startOffset;
		final int endOffset;

		private Location(Editor editor)
		{
			this.editor = editor;
			modificationStamp = editor != null ? editor.getDocument().getModificationStamp() : 0;
			startOffset = editor != null ? editor.getSelectionModel().getSelectionStart() : 0;
			endOffset = editor != null ? editor.getSelectionModel().getSelectionEnd() : 0;
		}

		public static Location fromEditor(Editor editor)
		{
			return new Location(editor);
		}

		public Editor getEditor()
		{
			return editor;
		}

		public long getModificationStamp()
		{
			return modificationStamp;
		}

		public int getStartOffset()
		{
			return startOffset;
		}

		public int getEndOffset()
		{
			return endOffset;
		}

		@Override
		public boolean equals(Object o)
		{
			if(this == o)
				return true;
			if(!(o instanceof Location))
				return false;

			Location location = (Location) o;

			if(endOffset != location.endOffset)
				return false;
			if(modificationStamp != location.modificationStamp)
				return false;
			if(startOffset != location.startOffset)
				return false;
			if(editor != null ? !editor.equals(location.editor) : location.editor != null)
				return false;

			return true;
		}

		@Override
		public int hashCode()
		{
			int result = editor != null ? editor.hashCode() : 0;
			result = 31 * result + (int) (modificationStamp ^ (modificationStamp >>> 32));
			result = 31 * result + startOffset;
			result = 31 * result + endOffset;
			return result;
		}
	}
}
